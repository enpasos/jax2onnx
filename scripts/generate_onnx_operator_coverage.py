#!/usr/bin/env python3
# scripts/generate_onnx_operator_coverage.py

"""Generate ONNX-operator-centric coverage docs from plugin sources."""

from __future__ import annotations

import argparse
import logging
import re
from collections import defaultdict
from pathlib import Path
from typing import DefaultDict
from urllib.request import urlopen

REPO_ROOT = Path(__file__).resolve().parent.parent
PLUGIN_ROOT = REPO_ROOT / "jax2onnx" / "plugins"
DEFAULT_OUTPUT = REPO_ROOT / "docs" / "user_guide" / "onnx_operator_coverage.md"

DEFAULT_INDEX_URL = "https://onnx.ai/onnx/operators/index.html"

TABLE_START = "<!-- AUTOGENERATED ONNX OPERATOR TABLE START -->"
TABLE_END = "<!-- AUTOGENERATED ONNX OPERATOR TABLE END -->"
EXTRA_START = "<!-- AUTOGENERATED ONNX OPERATOR EXTRA START -->"
EXTRA_END = "<!-- AUTOGENERATED ONNX OPERATOR EXTRA END -->"

INDEX_LINK_RE = re.compile(r'href="onnx__([A-Za-z0-9_]+)\.html"')
TITLE_RE = re.compile(r"<title>ONNX Operators - ([^<]+)</title>")
META_RE = re.compile(r"onnx__([A-Za-z0-9_]+)\.html")
BUILDER_RE = re.compile(r"\b(?:ctx\.)?builder\.([A-Z][A-Za-z0-9_]*)\s*\(")

logger = logging.getLogger("generate_onnx_operator_coverage")

_CONTAINER_PREFIXES = ("Sequence", "String", "Optional")
_QUANTIZATION_OPS = {
    "ConvInteger",
    "MatMulInteger",
    "QLinearConv",
    "QLinearMatMul",
    "QuantizeLinear",
    "DequantizeLinear",
    "DynamicQuantizeLinear",
}
_SPECIALIZED_OPS = {
    "GRU",
    "LSTM",
    "RNN",
    "STFT",
    "TfIdfVectorizer",
    "ImageDecoder",
    "RegexFullMatch",
}
_LOW_COMPLEXITY_MATH_OPS = {
    "Acos",
    "Acosh",
    "Asin",
    "Asinh",
    "Atan",
    "Atanh",
    "Ceil",
    "Round",
    "Reciprocal",
    "Tan",
}
_COMMON_MODEL_OPS = {
    "Flatten",
    "HardSigmoid",
    "HardSwish",
    "Hardmax",
    "PRelu",
    "ThresholdedRelu",
    "Swish",
    "SpaceToDepth",
    "Trilu",
    "Unique",
    "NonZero",
    "OneHot",
}

_JAX_OP_CANDIDATES: dict[str, tuple[str, ...]] = {
    "Acos": ("jax.lax.acos", "jax.numpy.arccos"),
    "Acosh": ("jax.lax.acosh", "jax.numpy.arccosh"),
    "Asin": ("jax.lax.asin", "jax.numpy.arcsin"),
    "Asinh": ("jax.lax.asinh", "jax.numpy.arcsinh"),
    "Atan": ("jax.lax.atan", "jax.numpy.arctan"),
    "Atanh": ("jax.lax.atanh", "jax.numpy.arctanh"),
    "Ceil": ("jax.lax.ceil", "jax.numpy.ceil"),
    "Reciprocal": ("jax.numpy.reciprocal", "jax.lax.integer_pow(x, -1)", "1.0 / x"),
    "ReduceL1": (
        "jax.numpy.linalg.norm(ord=1)",
        "jax.numpy.sum(jax.numpy.abs(x), axis=...)",
    ),
    "ReduceL2": (
        "jax.numpy.linalg.norm(ord=2)",
        "jax.numpy.sqrt(jax.numpy.sum(x * x, axis=...))",
    ),
    "ReduceLogSum": ("jax.numpy.log(jax.numpy.sum(x, axis=...))",),
    "ReduceLogSumExp": ("jax.nn.logsumexp", "jax.scipy.special.logsumexp"),
    "ReduceSumSquare": ("jax.numpy.sum(jax.numpy.square(x), axis=...)",),
    "Round": ("jax.lax.round", "jax.numpy.round"),
    "Tan": ("jax.lax.tan", "jax.numpy.tan"),
}

_EXTRA_JAX_OP_CANDIDATES: dict[str, tuple[str, ...]] = {
    "Bitcast": ("jax.lax.bitcast_convert_type",),
    "Complex": ("jax.lax.complex", "jax.numpy.asarray(..., dtype=complex64/128)"),
    "Flip": ("jax.lax.rev", "jax.numpy.flip"),
    "Sort": ("jax.lax.sort", "jax.numpy.sort"),
}


def fetch_official_operators(index_url: str) -> tuple[list[str], str]:
    with urlopen(index_url, timeout=20) as response:  # noqa: S310 (trusted docs URL)
        html = response.read().decode("utf-8", errors="ignore")
    operators = sorted(set(INDEX_LINK_RE.findall(html)))
    if not operators:
        raise RuntimeError(f"No operators found while parsing '{index_url}'.")

    title_match = TITLE_RE.search(html)
    source_title = title_match.group(1) if title_match else "ONNX Operators"
    return operators, source_title


def _module_id(path: Path) -> str:
    rel = path.relative_to(PLUGIN_ROOT).as_posix()
    return rel[:-3] if rel.endswith(".py") else rel


def collect_plugin_operator_usage(
    *,
    plugin_root: Path,
    include_examples: bool,
) -> tuple[DefaultDict[str, set[str]], DefaultDict[str, set[str]]]:
    metadata_usage: DefaultDict[str, set[str]] = defaultdict(set)
    lowering_usage: DefaultDict[str, set[str]] = defaultdict(set)

    for path in sorted(plugin_root.rglob("*.py")):
        rel_parts = path.relative_to(plugin_root).parts
        if not include_examples and rel_parts and rel_parts[0] == "examples":
            continue

        text = path.read_text(encoding="utf-8")
        module = _module_id(path)

        for op in META_RE.findall(text):
            metadata_usage[op].add(module)

        for op in BUILDER_RE.findall(text):
            lowering_usage[op].add(module)

    return metadata_usage, lowering_usage


def _format_modules(modules: set[str], max_items: int = 6) -> str:
    if not modules:
        return "➖"
    items = sorted(modules)
    lines = [f"`{name}`" for name in items[:max_items]]
    if len(items) > max_items:
        lines.append(f"... +{len(items) - max_items}")
    return "<br>".join(lines)


def _recommend_for_uncovered(op: str) -> str:
    if op.startswith(_CONTAINER_PREFIXES):
        return "If in scope, add container plugins; else mark explicitly out-of-scope."
    if op in _QUANTIZATION_OPS or "Quantize" in op or op.endswith("Integer"):
        return "Decide quantization scope, then add lowerings/tests or mark as not planned."
    if op in _SPECIALIZED_OPS:
        return "Add only when demanded by target models; document priority."
    if op.startswith("Reduce") or op in _LOW_COMPLEXITY_MATH_OPS:
        return "Good quick win: add primitive plugin, metadata, and expect_graph test."
    if "Pool" in op or op in _COMMON_MODEL_OPS:
        return (
            "Common model op; prioritize based on user demand and add regression tests."
        )
    return "Evaluate demand and either implement plugin support or document non-goal."


def _format_jax_candidates(
    op: str,
    *,
    has_coverage: bool,
) -> str:
    candidates = _JAX_OP_CANDIDATES.get(op)
    if candidates:
        return "<br>".join(f"`{item}`" for item in candidates)
    if has_coverage:
        return "Covered via existing plugin primitives."
    return "No clear direct primitive; likely composite JAX expression."


def _format_extra_jax_candidates(op: str) -> str:
    candidates = _EXTRA_JAX_OP_CANDIDATES.get(op)
    if not candidates:
        return "Internal alias/helper; map manually if needed."
    return "<br>".join(f"`{item}`" for item in candidates)


def _recommend_for_official_row(
    op: str,
    *,
    metadata_modules: set[str],
    lowering_modules: set[str],
) -> str:
    has_meta = bool(metadata_modules)
    has_lowering = bool(lowering_modules)
    if has_meta and has_lowering:
        return "Keep covered; broaden tests (dynamic shapes/dtypes/opset) and sync metadata."
    if has_meta and not has_lowering:
        return f"Add real lowering usage (`builder.{op}`) or remove stale metadata mapping."
    if has_lowering and not has_meta:
        return f"Add `onnx__{op}.html` metadata to owning `@register_primitive` entry."
    return _recommend_for_uncovered(op)


def _recommend_for_extra_row(
    op: str,
    *,
    metadata_modules: set[str],
    lowering_modules: set[str],
) -> str:
    has_meta = bool(metadata_modules)
    has_lowering = bool(lowering_modules)
    if op == "Complex":
        return "Internal helper op composition; keep as helper, not as ONNX coverage target."
    if has_meta and has_lowering:
        return "Verify operator naming against ONNX index and normalize metadata if needed."
    if has_meta and not has_lowering:
        return (
            "Metadata alias only; replace with official ONNX operator name or remove."
        )
    if has_lowering and not has_meta:
        return "Lowering alias/helper; map to official ONNX op name in metadata where possible."
    return "Review and classify this name explicitly (official op vs internal helper)."


def build_main_table(
    *,
    official_ops: list[str],
    metadata_usage: dict[str, set[str]],
    lowering_usage: dict[str, set[str]],
) -> tuple[str, int]:
    header = (
        "| ONNX Operator | In Plugins | Metadata | Lowering | Plugin Modules | Potential JAX Ops | Suggested Next Step |\n"
        "|:--------------|:-----------|:---------|:---------|:---------------|:------------------|:--------------------|"
    )

    rows: list[str] = []
    used_count = 0
    for op in official_ops:
        metadata_modules = metadata_usage.get(op, set())
        lowering_modules = lowering_usage.get(op, set())
        all_modules = metadata_modules | lowering_modules
        if all_modules:
            used_count += 1
        op_link = f"[{op}](https://onnx.ai/onnx/operators/onnx__{op}.html)"
        rows.append(
            "| "
            f"{op_link} | "
            f"{'✅' if all_modules else '➖'} | "
            f"{'✅' if metadata_modules else '➖'} | "
            f"{'✅' if lowering_modules else '➖'} | "
            f"{_format_modules(all_modules)} | "
            f"{_format_jax_candidates(op, has_coverage=bool(all_modules))} | "
            f"{_recommend_for_official_row(op, metadata_modules=metadata_modules, lowering_modules=lowering_modules)} |"
        )

    table = f"{header}\n" + "\n".join(rows)
    wrapped = (
        f'<div class="onnx-operator-coverage-table" markdown="1">\n\n{table}\n\n</div>'
    )
    return wrapped, used_count


def build_extra_table(
    *,
    official_ops: set[str],
    metadata_usage: dict[str, set[str]],
    lowering_usage: dict[str, set[str]],
) -> tuple[str, int]:
    extra_ops = sorted((set(metadata_usage) | set(lowering_usage)) - official_ops)
    if not extra_ops:
        return "No extra operator names found outside the ONNX index.", 0

    rows: list[str] = []
    for op in extra_ops:
        metadata_modules = metadata_usage.get(op, set())
        lowering_modules = lowering_usage.get(op, set())
        rows.append(
            "| "
            f"`{op}` | "
            f"{'✅' if metadata_modules else '➖'} | "
            f"{'✅' if lowering_modules else '➖'} | "
            f"{_format_modules(metadata_modules | lowering_modules)} | "
            f"{_format_extra_jax_candidates(op)} | "
            f"{_recommend_for_extra_row(op, metadata_modules=metadata_modules, lowering_modules=lowering_modules)} |"
        )

    header = (
        "| Name Found in Plugins | Metadata | Lowering | Plugin Modules | Potential JAX Ops | Suggested Next Step |\n"
        "|:----------------------|:---------|:---------|:---------------|:------------------|:--------------------|"
    )
    table = f"{header}\n" + "\n".join(rows)
    wrapped = (
        f'<div class="onnx-operator-extra-table" markdown="1">\n\n{table}\n\n</div>'
    )
    return wrapped, len(extra_ops)


def replace_marked_section(
    *,
    content: str,
    start_marker: str,
    end_marker: str,
    replacement: str,
) -> str:
    start = content.find(start_marker)
    end = content.find(end_marker)
    if start == -1 or end == -1:
        raise RuntimeError(
            f"Markers '{start_marker}'/'{end_marker}' not found in coverage doc."
        )
    return (
        content[:start]
        + f"{start_marker}\n\n{replacement}\n\n{end_marker}"
        + content[end + len(end_marker) :]
    )


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate ONNX-operator coverage docs from plugin sources."
    )
    parser.add_argument(
        "--index-url",
        default=DEFAULT_INDEX_URL,
        help="Official ONNX operator index URL.",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT,
        help="Path to docs file with AUTOGENERATED markers.",
    )
    parser.add_argument(
        "--include-examples",
        action="store_true",
        help="Also scan modules under jax2onnx/plugins/examples.",
    )
    return parser.parse_args()


def main() -> None:
    logging.basicConfig(level=logging.INFO, format="%(message)s")
    args = parse_args()

    official_ops, source_title = fetch_official_operators(args.index_url)
    metadata_usage, lowering_usage = collect_plugin_operator_usage(
        plugin_root=PLUGIN_ROOT,
        include_examples=args.include_examples,
    )

    main_table, used_count = build_main_table(
        official_ops=official_ops,
        metadata_usage=metadata_usage,
        lowering_usage=lowering_usage,
    )
    extra_table, extra_count = build_extra_table(
        official_ops=set(official_ops),
        metadata_usage=metadata_usage,
        lowering_usage=lowering_usage,
    )

    summary = "\n".join(
        [
            f"- Source index: `{source_title}` (`{args.index_url}`)",
            f"- Operators in index: `{len(official_ops)}`",
            f"- Operators referenced in plugins: `{used_count}`",
            f"- Coverage: `{used_count / len(official_ops):.1%}`",
            "- `Potential JAX Ops` lists candidate JAX entry points for each operator.",
            "- `Suggested Next Step` is heuristic and should be refined with roadmap priorities.",
        ]
    )
    if extra_count:
        summary += f"\n- Extra plugin names not present in index: `{extra_count}`"

    output_text = args.output.read_text(encoding="utf-8")
    output_text = replace_marked_section(
        content=output_text,
        start_marker=TABLE_START,
        end_marker=TABLE_END,
        replacement=f"{summary}\n\n{main_table}",
    )
    output_text = replace_marked_section(
        content=output_text,
        start_marker=EXTRA_START,
        end_marker=EXTRA_END,
        replacement=extra_table,
    )
    args.output.write_text(output_text, encoding="utf-8")

    logger.info("Updated %s", args.output)


if __name__ == "__main__":
    main()
