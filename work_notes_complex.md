# Work Notes: Complex Numbers in jax2onnx (Issue #193)

## Issue Overview
Users discovered a `NotImplementedError: [converter] No plugins registered for primitive 'complex'` during ONNX export when running `jax.lax.complex(real, imag)` or `jax.numpy.complex(real, imag)`.

## Current State of Complex Handling
According to the developer guide (`docs/developer_guide/advanced_topics/complex_numbers.md`), `jax2onnx` employs a consistent architecture to handle complex numbers without relying on non-standard ONNX operators:

1.  **Representation Strategy:** ONNX specifies no native `tensor(complex*)` types across its core operators. `jax2onnx` completely bypasses this limitation by representing all complex tensors as **real tensors with an extra trailing dimension of size 2** `(shape=[..., 2])`, corresponding to the real and imaginary channels. 
2.  **Shared Helpers:** A suite of utilities is located in `jax2onnx/plugins/_complex_utils.py`, providing canonical pathways to cast native JAX complex values into these standard packed real tensors (`pack_native_complex`, `ensure_packed_real_pair`) and to split or reconstruct them without ad-hoc custom nodes.

### Analyzing the User's Observation
The user in Issue #193 believed complex support "used to work" and assumed `real` and `imag` projections must be missing as well. 

**Our findings:**
1.  **Arithmetic and Projections Work Perfectly:** By inspecting `jax2onnx/plugins/jax/lax`, plugins for `real.py` and `imag.py` *already exist* and properly split the trailing dimension. Further, plugins for math ops (e.g., `add.py`, `fft.py`, `mul.py`) all correctly intercept and process complex tensors natively. The user likely experienced these working ops previously (for example, generating complex variables naturally via FFTs or matmuls) and assumed general support.
2.  **The Constructor is Missing:** The explicit `jax.lax.complex` constructor traces directly to JAX's fundamental `complex` native primitive. Surprisingly, amongst all the robust arithmetic plugins, a dedicated `PrimitiveLeafPlugin` registering the lowering behavior for this specific `complex` constructor primitive was simply overlooked or omitted during development.

## Implementation Concept

To resolve `#193` in full alignment with the architecture outlined in `docs/developer_guide/advanced_topics/complex_numbers.md`, we must implement a new plugin.

### The Fix
Create a new file: `jax2onnx/plugins/jax/lax/complex.py`

**Plugin Details:**
*   **Primitive mapping:** Target `jax.lax.complex_p`
*   **ONNX Mappings:** It leverages `Unsqueeze` and `Concat` nodes natively.
*   **Lowering Logic:** The `lower` method should extract the `real` and `imag` input `ir.Value` arguments. These should both ideally be of standard real float types. It then calls the pre-existing helper `pack_real_imag_pair(ctx, real, imag, base_dtype=...)` from `_complex_utils.py`. The result will correctly be the required `[... , 2]` packed representation for complex numbers, maintaining 100% adherence to the core strategyâ€”using standard real-valued ops exclusively.

### Testing Plan
The implementation should be tested via the standard autogenerated harness `t_generator.py` by placing testcases directly in the plugin file `plugins/jax/lax/complex.py`.

*   **Test Case 1:** Combine standard scalar precision float arrays.
*   **Test Case 2:** Combine multidimensional float arrays.
*   These tests should assert that the final ONNX output returns the expected packed tensors and is fully export-compatible.
