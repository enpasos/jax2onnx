import onnx_ir as ir
import numpy as np
import os
import sys
import textwrap


def generate_ir_script(model_path: str, output_script_path: str):
    """
    Loads an ONNX model and generates a Python script to recreate it,
    saving the script to the specified output path.
    """
    print(f"Loading and analyzing model from '{model_path}'...", file=sys.stderr)
    try:
        model = ir.load(model_path)
    except Exception as e:
        print(f"Error: Could not load the ONNX model. {e}", file=sys.stderr)
        return

    graph = model.graph

    # --- Script Generation ---
    script_lines = [
        "import onnx_ir as ir",
        "from onnx_ir import SymbolicDim",
        "import numpy as np",
        "import os",
        "",
        "# --- Auto-generated by ONNX Decompiler ---",
        "",
        "# === Step 1: Define ALL values in the graph ===",
        "# This includes inputs, initializers, and all intermediate tensors.",
        "",
    ]

    # --- Value and Initializer Definitions ---
    all_values = {}
    value_defs = []

    # Graph Inputs
    for val in graph.inputs:
        # THE FIX: Use repr() for a robust shape string representation
        shape_str = f"ir.Shape({repr(val.shape.dims)})" if val.shape else "None"
        value_defs.append(
            f'{val.name} = ir.Value(name="{val.name}", shape={shape_str}, type=ir.TensorType(ir.DataType.{val.dtype.name}))'
        )
        all_values[val.name] = val.name

    # Initializers
    for val in graph.initializers.values():
        np_array = val.const_value.numpy()
        dtype_str = f"ir.DataType.{val.dtype.name}"
        array_str = np.array2string(np_array, threshold=sys.maxsize, separator=", ")
        shape_str = f"ir.Shape({repr(val.shape.dims)})"

        value_defs.append(f"# Initializer for {val.name}")
        value_defs.append(
            f"{val.name}_val = np.array({array_str}, dtype=np.{val.dtype.numpy().name})"
        )
        value_defs.append(
            f'{val.name} = ir.Value(name="{val.name}", type=ir.TensorType({dtype_str}), shape={shape_str}, const_value=ir.tensor({val.name}_val))'
        )
        all_values[val.name] = val.name

    # Intermediate and Output values
    for node in graph:
        for val in node.outputs:
            if val.name in all_values:
                continue

            shape_str = f"ir.Shape({repr(val.shape.dims)})" if val.shape else "None"
            type_str = (
                f"ir.TensorType(ir.DataType.{val.dtype.name})" if val.dtype else "None"
            )

            value_defs.append(
                f'{val.name} = ir.Value(name="{val.name}", shape={shape_str}, type={type_str})'
            )
            all_values[val.name] = val.name

    script_lines.extend(value_defs)
    script_lines.append("\n# === Step 2: Define the nodes manually ===")

    # --- Node Definitions ---
    node_defs = []
    node_list_names = []
    for i, node in enumerate(graph):
        node_name = f"node_{i}"
        inputs_str = ", ".join([inp.name if inp else "None" for inp in node.inputs])
        outputs_str = ", ".join([out.name for out in node.outputs])

        attrs = node.attributes
        if attrs:
            attr_strs = []
            for k, v in attrs.items():
                val_repr = repr(v.value)
                if isinstance(v.value, ir.Graph):
                    val_repr = (
                        f"ir.Graph(...) # Subgraph {v.value.name} needs to be defined"
                    )
                attr_strs.append(f'"{k}": {val_repr}')
            attrs_str = f"attributes={{{', '.join(attr_strs)}}}"
        else:
            attrs_str = ""

        node_defs.append(
            f'{node_name} = ir.node(op_type="{node.op_type}", inputs=[{inputs_str}], outputs=[{outputs_str}], {attrs_str})'
        )
        node_list_names.append(node_name)

    script_lines.extend(node_defs)

    # --- Final Assembly ---
    script_lines.append("\n# === Step 3: Construct the Graph and Model ===")

    graph_inputs_str = ", ".join([val.name for val in graph.inputs])
    graph_outputs_str = ", ".join([val.name for val in graph.outputs])
    graph_nodes_str = ", ".join(node_list_names)
    graph_inits_str = ", ".join([val.name for val in graph.initializers.values()])
    opset_str = str(graph.opset_imports)

    script_lines.append(
        textwrap.dedent(
            f"""
graph = ir.Graph(
    inputs=[{graph_inputs_str}],
    outputs=[{graph_outputs_str}],
    nodes=[{graph_nodes_str}],
    initializers=[{graph_inits_str}],
    name="{graph.name}",
    opset_imports={opset_str}
)

model = ir.Model(graph, ir_version={model.ir_version})
"""
        )
    )

    # --- Add the save step to the generated script ---
    script_lines.append("\n# === Step 4: Save the Model ===")
    script_lines.append('output_dir = "recreated_model"')
    script_lines.append("if not os.path.exists(output_dir): os.makedirs(output_dir)")
    script_lines.append(
        'output_path = os.path.join(output_dir, "recreated_model.onnx")'
    )
    script_lines.append("print(f\"Saving recreated model to '{{output_path}}'...\")")
    script_lines.append("ir.save(model, output_path)")
    script_lines.append('print("✅ Model recreated and saved successfully.")')

    # --- Write the generated script to the output file ---
    output_dir = os.path.dirname(output_script_path)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    with open(output_script_path, "w", encoding="utf-8") as f:
        f.write("\n".join(script_lines))

    print(f"✅ Decompiler script saved to '{output_script_path}'", file=sys.stderr)


if __name__ == "__main__":
    m = "simple_cnn"

    # Input path for the ONNX model
    model_path_arg = "./docs/onnx/examples/nnx/" + m + ".onnx"
    # Output path for the generated Python script
    output_script_path_arg = "./jax2onnx/sandbox/" + m + ".py"

    if not os.path.exists(model_path_arg):
        print(f"Error: Model file not found at '{model_path_arg}'", file=sys.stderr)
    else:
        generate_ir_script(model_path_arg, output_script_path_arg)
